package coroutine

/**
 * Параллельные вычисления позволяют выполнять несколько задач одновременно,
 * а асинхронность позволяет не блокировать основной ход приложения
 * во время выполнения задачи, которая занимает продолжительное время.
 * В языке Kotlin поддержка асинхронности и параллельных вычислений
 * воплощена в виде корутин (coroutine).
 *
 * В ряде языков программирования есть такие структуры,
 * которые позволяют использовать потоки.
 * Однако между корутинами и потоками нет прямого соответствия.
 * Корутина не привязана к конкретному потоку.
 * Она может быть приостановить выполнение в одном потоке,
 * а возобновить выполнение в другом.
 * Когда корутина приостанавливает свое выполнение,
 * например, как в случае выше при вызове задержки с помощью функции delay(),
 * эта корутина освобождает поток, в котором она выполнялась, и сохраняется в памяти.
 * А освобожденный поток может быть зайдествован для других задач.
 * А когда завершается запущенная задача (например, выполнение функции delay()),
 * корутина возобновляет свою работу в одном из свободных потоков.
 */
import kotlinx.coroutines.*

suspend fun main() {
    //ex1()
    //ex2()
    //doWork()
    //runBlock()
    job()
}

/**
 * Модификатор suspend определяет функцию,
 * которая может приостановить свое выполнение
 * и возобновить его через некоторый период времени.
 * Любая функция с модификатором suspend
 * может вызываться либо из другой функции,
 * которая тоже имеет модификатор suspend, либо из корутины.
 */
private suspend fun ex1() {
    for (i in 0..5) {
        delay(400L) //задержку в 400 миллисекунд
        println(i)
    }
    println("Hello Coroutines") //ждет завершение цикла
}

/**
 * Прежде всего для определения и выполнения корутины
 * нам надо определить для нее контекст, так как корутина может вызываться
 * только в контексте корутины (coroutine scope).
 * Для этого применяется функция coroutineScope()
 * - создает контекст корутины.
 * Кроме того, эта функция ожидает выполнения
 * всех определенных внутри нее корутин.
 * Стоит отметить, что coroutineScope() может применяться
 * только в функции с модификатором suspend.
 *
 * Сама корутина определяется и запускается
 * с помощью построителя корутин - функции launch.
 */
private suspend fun ex2() {
    coroutineScope {
        launch {
            for (i in 0..5) {
                delay(400L)
                println(i)
            }
        }
        println("Hello Coroutines") //не ждет завершенияцикла
    }
}

/**
 * Корутина может выполняться только в определенной области корутины (coroutine scope).
 * Область корутин представляет пространство,
 * в рамках которого действуют корутины,
 * она имеет определенный жизненный цикл
 * и сама управляет жизненным циклом создаваемых внутри нее корутин.
 *
 * Можно запускать в одной функции сразу несколько корутин.
 * И они будут выполняться одновременно.
 *
 * Функция, которая создает область корутин,
 * будет ожидать завершения всех определенных в этой области корутин.
 */
suspend fun doWork() = coroutineScope {
    launch {
        for (i in 0..5) {
            println(i)
            delay(400L)
        }
    }
    launch {
        for (i in 6..10) {
            delay(400L)
            println(i)
        }
    }
}

/**
 * Функция runBlocking блокирует вызывающий поток,
 * пока все корутины внутри вызова runBlocking { ... } не завершат свое выполнение.
 * В этом собственно основное отличие runBlocking от coroutineScope:
 * coroutineScope не блокирует вызывающий поток,
 * а просто приостанавливает выполнение,
 * освобождая поток для использования другими ресурсами.
 */
suspend fun runBlock() = runBlocking {
    launch {
        for (i in 0..5) {
            println(i)
            delay(400L)
        }
    }
    launch {
        for (i in 6..10) {
            delay(400L)
            println(i)
        }
    }
    //Одна корутина может содержать другие корутины.
    //внешние корутины определяют область для вложенных корутин
    //и управляют их жизненным циклом.
    launch {
        println("Outer coroutine")
        launch {
            println("Inner coroutine")
            delay(400L)
        }
    }
}

suspend fun job() = coroutineScope{
    val job = launch{
        for(i in 1..5){
            println(i)
            delay(400L)
        }
    }
    println("Start")
    job.join() // ожидаем завершения корутины
    println("End")

    // корутина создана, но не запущена
    val lazyJob = launch(start = CoroutineStart.LAZY) {
        delay(200L)
        println("Coroutine has started")
    }
    delay(1000L)
    lazyJob.start() // запускаем корутину
}
