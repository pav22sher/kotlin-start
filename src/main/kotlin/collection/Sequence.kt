package collection

/**
 * Наряду с коллекциями Kotlin предоставляет еще один тип наборов элементов
 * – последовательности (sequences). (java stream api - ленивая обработка и т.д.)
 * Последовательности предоставляют похожую функциональность,
 * что и интерфейс Iterable, который реализуется типами коллекций.
 * Ключевая разница состоит в том, как обрабатываются элементы последовательности
 * при применении к ним набора операций.
 *
 * Интерфейс Sequence предоставляет ряд функций,
 * который позволяют производить различные операции с последовательностями.
 * Все операции с последовательностями делятся на ряд типов.
 *
 * Операции мб intermediate - промежуточными и возвращать другую последовательность.
 * Операции мб terminal - конечными - выполняются сразу и выдают результат
 *
 * Операции могут хранить состояние (statefull-операции),
 * например, операция distinct().
 * Операции могут НЕ хранить состояние (stateless-операции),
 * например, операция filter()
 */
fun main() {
    val people = sequenceOf("Tom", "Sam", "Bob")
    println(people.joinToString())
    val employees = listOf("Tom", "Sam", "Bob") .asSequence()
    println(employees.joinToString())
    //генерация бесконечной последовательности
    var number = 0
    val numbers1 = generateSequence{ number += 2; number}
    println(numbers1.take(5).joinToString())

    val numbers2 = sequence {
        yield(1)
        yield(4)
        yield(7)
    }
    println(numbers2.joinToString())

    /**
     * Так, при применении набора операций к коллекции Iterable
     * каждая отдельная операция возвращает промежуточный результат
     * - промежуточную коллекцию.
     * А при обработке последовательности
     * весь набор операций выполняется только тогда,
     * когда требуется конечный результат обработки.
     *
     * Также меняется порядок применения операций.
     * Коллекция применяет каждую операцию последовательно к каждому элементу.
     * То есть сначала выполняет первую операцию для всех элементов,
     * потом вторую операцию для элементов коллекции,
     * полученных после первой операции. И так далее.
     *
     * Последовательность применяет весь набор операций отдельно к каждому элементу.
     * То есть сначала весь набор операций применяется к первому элементу,
     * потом ко второму элементу и так далее.
     * Таким образом, последовательность позволяет
     * избежать создания помежуточных коллекций
     * и в тоже время повышают производительность
     * при выполнении набора операций особенно для большого набора данных.
     */
    testCollection()
    testSequence()
}

fun testSequence() {
    var people = sequenceOf(
        Person("Tom", 37),
        Person("Sam", 25),
        Person("Alice", 33)
    )
    people = people
        .filter { println("Age filter: ${it}"); it.age > 30 }
        .take(1)
    for(person in people) println(person)
}

fun testCollection() {
    var people = listOf(
        Person("Tom", 37),
        Person("Sam", 25),
        Person("Alice", 33)
    )
    people = people
        .filter { println("Age filter: ${it}"); it.age > 30 }
        .take(1)
    for(person in people) println(person)
}

data class Person(val name: String, val age: Int)
